{"ast":null,"code":"/**\r\n *\r\n * @namespace faker.datatype\r\n */\nfunction Datatype(faker, seed) {\n  // Use a user provided seed if it is an array or number\n  if (Array.isArray(seed) && seed.length) {\n    faker.mersenne.seed_array(seed);\n  } else if (!isNaN(seed)) {\n    faker.mersenne.seed(seed);\n  }\n\n  /**\r\n     * returns a single random number based on a max number or range\r\n     *\r\n     * @method faker.datatype.number\r\n     * @param {mixed} options {min, max, precision}\r\n     */\n  this.number = function (options) {\n    if (typeof options === \"number\") {\n      options = {\n        max: options\n      };\n    }\n    options = options || {};\n    if (typeof options.min === \"undefined\") {\n      options.min = 0;\n    }\n    if (typeof options.max === \"undefined\") {\n      options.max = 99999;\n    }\n    if (typeof options.precision === \"undefined\") {\n      options.precision = 1;\n    }\n\n    // Make the range inclusive of the max value\n    var max = options.max;\n    if (max >= 0) {\n      max += options.precision;\n    }\n    var randomNumber = Math.floor(faker.mersenne.rand(max / options.precision, options.min / options.precision));\n    // Workaround problem in Float point arithmetics for e.g. 6681493 / 0.01\n    randomNumber = randomNumber / (1 / options.precision);\n    return randomNumber;\n  };\n\n  /**\r\n     * returns a single random floating-point number based on a max number or range\r\n     *\r\n     * @method faker.datatype.float\r\n     * @param {mixed} options\r\n     */\n  this.float = function (options) {\n    if (typeof options === \"number\") {\n      options = {\n        precision: options\n      };\n    }\n    options = options || {};\n    var opts = {};\n    for (var p in options) {\n      opts[p] = options[p];\n    }\n    if (typeof opts.precision === 'undefined') {\n      opts.precision = 0.01;\n    }\n    return faker.datatype.number(opts);\n  };\n\n  /**\r\n     * method returns a Date object using a random number of milliseconds since 1. Jan 1970 UTC\r\n     * Caveat: seeding is not working\r\n     *\r\n     * @method faker.datatype.datetime\r\n     * @param {mixed} options, pass min OR max as number of milliseconds since 1. Jan 1970 UTC\r\n     */\n  this.datetime = function (options) {\n    if (typeof options === \"number\") {\n      options = {\n        max: options\n      };\n    }\n    var minMax = 8640000000000000;\n    options = options || {};\n    if (typeof options.min === \"undefined\" || options.min < minMax * -1) {\n      options.min = new Date().setFullYear(1990, 1, 1);\n    }\n    if (typeof options.max === \"undefined\" || options.max > minMax) {\n      options.max = new Date().setFullYear(2100, 1, 1);\n    }\n    var random = faker.datatype.number(options);\n    return new Date(random);\n  };\n\n  /**\r\n     * Returns a string, containing UTF-16 chars between 33 and 125 ('!' to '}')\r\n     *\r\n     *\r\n     * @method faker.datatype.string\r\n     * @param { number } length: length of generated string, default = 10, max length = 2^20\r\n     */\n  this.string = function (length) {\n    if (length === undefined) {\n      length = 10;\n    }\n    var maxLength = Math.pow(2, 20);\n    if (length >= maxLength) {\n      length = maxLength;\n    }\n    var charCodeOption = {\n      min: 33,\n      max: 125\n    };\n    var returnString = '';\n    for (var i = 0; i < length; i++) {\n      returnString += String.fromCharCode(faker.datatype.number(charCodeOption));\n    }\n    return returnString;\n  };\n\n  /**\r\n     * uuid\r\n     *\r\n     * @method faker.datatype.uuid\r\n     */\n  this.uuid = function () {\n    var RFC4122_TEMPLATE = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n    var replacePlaceholders = function replacePlaceholders(placeholder) {\n      var random = faker.datatype.number({\n        min: 0,\n        max: 15\n      });\n      var value = placeholder == 'x' ? random : random & 0x3 | 0x8;\n      return value.toString(16);\n    };\n    return RFC4122_TEMPLATE.replace(/[xy]/g, replacePlaceholders);\n  };\n\n  /**\r\n     * boolean\r\n     *\r\n     * @method faker.datatype.boolean\r\n     */\n  this.boolean = function () {\n    return !!faker.datatype.number(1);\n  };\n\n  /**\r\n     * hexaDecimal\r\n     *\r\n     * @method faker.datatype.hexaDecimal\r\n     * @param {number} count defaults to 1\r\n     */\n  this.hexaDecimal = function hexaDecimal(count) {\n    if (typeof count === \"undefined\") {\n      count = 1;\n    }\n    var wholeString = \"\";\n    for (var i = 0; i < count; i++) {\n      wholeString += faker.random.arrayElement([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]);\n    }\n    return \"0x\" + wholeString;\n  };\n\n  /**\r\n     * returns json object with 7 pre-defined properties\r\n     *\r\n     * @method faker.datatype.json\r\n     */\n  this.json = function json() {\n    var properties = ['foo', 'bar', 'bike', 'a', 'b', 'name', 'prop'];\n    var returnObject = {};\n    properties.forEach(function (prop) {\n      returnObject[prop] = faker.datatype.boolean() ? faker.datatype.string() : faker.datatype.number();\n    });\n    return JSON.stringify(returnObject);\n  };\n\n  /**\r\n     * returns an array with values generated by faker.datatype.number and faker.datatype.string\r\n     *\r\n     * @method faker.datatype.array\r\n     * @param { number } length of the returned array\r\n     */\n\n  this.array = function array(length) {\n    if (length === undefined) {\n      length = 10;\n    }\n    var returnArray = new Array(length);\n    for (var i = 0; i < length; i++) {\n      returnArray[i] = faker.datatype.boolean() ? faker.datatype.string() : faker.datatype.number();\n    }\n    return returnArray;\n  };\n  return this;\n}\nmodule['exports'] = Datatype;","map":null,"metadata":{},"sourceType":"script"}